"""
WEP Core Encryption/Decryption Module
Educational Purpose Only
"""

import os
import random
import binascii
from collections import defaultdict
from .rc4 import RC4


class WEPCore:
    """WEP encryption/decryption core"""
    
    # Known weak IV patterns for FMS attack
    WEAK_IV_PATTERNS = [
        lambda iv: iv[0] + 3 == iv[1] and iv[1] == 255,  # Classic FMS
        lambda iv: iv[0] + 3 == iv[1] and iv[2] > 127,   # Extended
        lambda iv: iv[0] + 3 == iv[1] and iv[2] < 64,    # Another variant
    ]
    
    def __init__(self):
        self.keys = {}  # BSSID -> key mapping
        self.iv_pool = set()
        self.weak_ivs = []
        self.iv_statistics = defaultdict(int)
        
    def set_key(self, bssid, key_string, key_size=104):
        """
        Set WEP key for a specific BSSID
        
        Args:
            bssid: BSSID of the network
            key_string: ASCII key string
            key_size: Key size in bits (40 or 104)
        """
        # Convert string to key bytes
        key_bytes = key_string.encode('utf-8')
        target_len = key_size // 8
        
        if len(key_bytes) < target_len:
            # Pad with zeros
            key_bytes = key_bytes.ljust(target_len, b'\x00')
        else:
            # Truncate
            key_bytes = key_bytes[:target_len]
        
        self.keys[bssid] = {
            'string': key_string,
            'bytes': key_bytes,
            'size': key_size,
            'hex': binascii.hexlify(key_bytes).decode().upper()
        }
        
        return self.keys[bssid]
    
    def encrypt(self, data, bssid=None, key_bytes=None, iv=None):
        """
        Encrypt data with WEP
        
        Args:
            data: Bytes to encrypt
            bssid: BSSID to use key from (if key_bytes not provided)
            key_bytes: Direct key bytes (if bssid not provided)
            iv: Initialization Vector (3 bytes), generated if None
            
        Returns:
            bytes: IV + encrypted data
        """
        # Get key bytes
        if key_bytes is None and bssid is not None:
            if bssid not in self.keys:
                raise ValueError(f"No key set for BSSID {bssid}")
            key_bytes = self.keys[bssid]['bytes']
        elif key_bytes is None:
            raise ValueError("Either bssid or key_bytes must be provided")
        
        # Generate IV if not provided
        if iv is None:
            iv = os.urandom(3)
        elif len(iv) != 3:
            raise ValueError("IV must be 3 bytes")
        
        # Track IV for statistics
        iv_hex = binascii.hexlify(iv).decode()
        self.iv_statistics[iv_hex] += 1
        
        # Check if weak IV
        if self.is_weak_iv(iv):
            self.weak_ivs.append({
                'iv': iv_hex,
                'timestamp': __import__('time').time()
            })
        
        # Create full key (IV + secret key)
        full_key = list(iv) + list(key_bytes)
        
        # Calculate ICV (simplified CRC-32 for simulation)
        icv = self.calculate_icv(data)
        
        # Encrypt data + ICV
        rc4 = RC4(full_key)
        encrypted = rc4.crypt(data + icv)
        
        return iv + encrypted
    
    def decrypt(self, data, bssid=None, key_bytes=None):
        """
        Decrypt WEP encrypted data
        
        Args:
            data: Bytes to decrypt (IV + encrypted data)
            bssid: BSSID to use key from
            key_bytes: Direct key bytes
            
        Returns:
            tuple: (decrypted_data, icv_valid)
        """
        if len(data) < 4:
            return None, False
        
        # Extract IV and ciphertext
        iv = data[:3]
        ciphertext = data[3:]
        
        # Get key bytes
        if key_bytes is None and bssid is not None:
            if bssid not in self.keys:
                raise ValueError(f"No key set for BSSID {bssid}")
            key_bytes = self.keys[bssid]['bytes']
        elif key_bytes is None:
            raise ValueError("Either bssid or key_bytes must be provided")
        
        # Create full key
        full_key = list(iv) + list(key_bytes)
        
        # Decrypt
        rc4 = RC4(full_key)
        decrypted = rc4.crypt(ciphertext)
        
        # Separate data and ICV
        if len(decrypted) < 4:
            return decrypted, False
        
        plaintext = decrypted[:-4]
        received_icv = decrypted[-4:]
        
        # Verify ICV
        calculated_icv = self.calculate_icv(plaintext)
        icv_valid = (received_icv == calculated_icv)
        
        return plaintext, icv_valid
    
    def calculate_icv(self, data):
        """
        Calculate Integrity Check Value (simplified CRC-32 for simulation)
        
        In real WEP, this is CRC-32. For simulation, we use a simpler
        algorithm to demonstrate the concept.
        """
        crc = 0xFFFFFFFF
        for byte in data:
            crc ^= byte
            for _ in range(8):
                if crc & 1:
                    crc = (crc >> 1) ^ 0xEDB88320
                else:
                    crc >>= 1
        return struct.pack('<I', (~crc) & 0xFFFFFFFF)
    
    def is_weak_iv(self, iv):
        """Check if an IV is weak (vulnerable to FMS attack)"""
        iv_tuple = tuple(iv)
        return any(pattern(iv_tuple) for pattern in self.WEAK_IV_PATTERNS)
    
    def get_iv_statistics(self):
        """Get IV usage statistics"""
        total_ivs = sum(self.iv_statistics.values())
        weak_count = len(self.weak_ivs)
        
        return {
            'total_ivs': total_ivs,
            'unique_ivs': len(self.iv_statistics),
            'weak_ivs': weak_count,
            'weak_percentage': (weak_count / total_ivs * 100) if total_ivs > 0 else 0,
            'iv_distribution': dict(self.iv_statistics)
        }
    
    def clear_statistics(self):
        """Clear IV statistics"""
        self.iv_statistics.clear()
        self.weak_ivs.clear()


# Helper function for struct pack (to avoid circular imports)
import struct
