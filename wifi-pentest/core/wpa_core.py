"""
WPA/WPA2 Core Functions Module
Educational Purpose Only
"""

import hashlib
import hmac
import os
import binascii
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.backends import default_backend


class WPACore:
    """WPA/WPA2 core functions"""
    
    def __init__(self):
        self.psk = None
        self.ssid = None
        self.handshakes = []
        
    def generate_pmk(self, password, ssid):
        """
        Generate Pairwise Master Key using PBKDF2
        
        Args:
            password: WPA password
            ssid: Network SSID
            
        Returns:
            bytes: 32-byte PMK
        """
        # WPA uses 4096 iterations of HMAC-SHA1
        # Using PBKDF2HMAC from cryptography library
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA1(),
            length=32,
            salt=ssid.encode('utf-8'),
            iterations=4096,
            backend=default_backend()
        )
        return kdf.derive(password.encode('utf-8'))
    
    def generate_pmk_legacy(self, password, ssid):
        """
        Legacy PMK generation using hashlib (fallback method)
        """
        return hashlib.pbkdf2_hmac('sha1', 
                                  password.encode('utf-8'),
                                  ssid.encode('utf-8'),
                                  4096, 32)
    
    def generate_ptk(self, pmk, anonce, snonce, amac, smac):
        """
        Generate Pairwise Transient Key
        
        Args:
            pmk: Pairwise Master Key
            anonce: Authenticator nonce
            snonce: Supplicant nonce
            amac: Authenticator MAC
            smac: Supplicant MAC
            
        Returns:
            dict: PTK components
        """
        # Sort MAC addresses (required by standard)
        if amac < smac:
            mac1, mac2 = amac, smac
            nonce1, nonce2 = anonce, snonce
        else:
            mac1, mac2 = smac, amac
            nonce1, nonce2 = snonce, anonce
        
        # Combine all data
        data = (b"Pairwise key expansion" +
                mac1.encode() + mac2.encode() +
                nonce1 + nonce2)
        
        # Generate PTK using multiple HMAC-SHA1 iterations
        ptk = b""
        for i in range(4):  # 384 bits = 4 * 160 bits (SHA1 output)
            h = hmac.new(pmk, data + bytes([i]), hashlib.sha1)
            ptk += h.digest()
        
        # Split PTK into components
        return {
            'kck': ptk[0:16],   # Key Confirmation Key
            'kek': ptk[16:32],  # Key Encryption Key
            'tk': ptk[32:48],   # Temporal Key (for CCMP/TKIP)
            'mic_tx': ptk[48:64], # Michael MIC keys (TKIP)
            'mic_rx': ptk[64:80] if len(ptk) > 64 else None
        }
    
    def calculate_mic(self, key, data):
        """
        Calculate Message Integrity Code
        
        Args:
            key: MIC key (KCK for EAPOL, or Michael key for TKIP)
            data: Data to calculate MIC for
            
        Returns:
            bytes: MIC value
        """
        # For EAPOL frames, uses HMAC-SHA1-128
        return hmac.new(key, data, hashlib.sha1).digest()[:16]
    
    def verify_handshake(self, handshake_data, password):
        """
        Verify if a password matches a captured handshake
        
        Args:
            handshake_data: Dictionary with handshake components
            password: Password to test
            
        Returns:
            bool: True if password matches
        """
        try:
            # Generate PMK from password
            pmk = self.generate_pmk_legacy(password, handshake_data['ssid'])
            
            # Generate PTK
            ptk = self.generate_ptk(
                pmk,
                handshake_data['anonce'],
                handshake_data['snonce'],
                handshake_data['amac'],
                handshake_data['smac']
            )
            
            # Calculate MIC for message 2 or 4
            mic = self.calculate_mic(ptk['kck'], handshake_data['eapol_data'])
            
            # Compare with captured MIC
            return mic == handshake_data['mic']
            
        except Exception:
            return False
    
    def parse_handshake(self, pcap_data):
        """
        Parse handshake from captured packets (simplified)
        """
        handshake = {
            'timestamp': __import__('time').time(),
            'ssid': 'TestNetwork',
            'bssid': '00:11:22:33:44:55',
            'client': '66:77:88:99:aa:bb',
            'anonce': os.urandom(32),
            'snonce': os.urandom(32),
            'mic': os.urandom(16),
            'eapol_data': os.urandom(100)
        }
        return handshake
    
    def pmkid_calculation(self, pmk, ap_mac, client_mac):
        """
        Calculate PMKID for WPA3/OWE transition mode
        
        PMKID = HMAC-SHA1(PMK, "PMK Name" | AP_MAC | Client_MAC)
        """
        data = b"PMK Name" + ap_mac.encode() + client_mac.encode()
        return hmac.new(pmk, data, hashlib.sha1).digest()[:16]


# For testing
if __name__ == "__main__":
    wpa = WPACore()
    
    # Test PMK generation
    pmk = wpa.generate_pmk_legacy("password123", "TestNetwork")
    print(f"PMK: {binascii.hexlify(pmk).decode()}")
    
    # Test PTK generation
    ptk = wpa.generate_ptk(
        pmk,
        os.urandom(32),
        os.urandom(32),
        "00:11:22:33:44:55",
        "66:77:88:99:aa:bb"
    )
    print(f"KCK: {binascii.hexlify(ptk['kck']).decode()}")