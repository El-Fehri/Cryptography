"""
Base Attack Class Module
Educational Purpose Only
"""

import threading
import time
from abc import ABC, abstractmethod


class AttackBase(ABC):
    """Abstract base class for all attacks"""
    
    def __init__(self, interface=None):
        """
        Initialize attack base
        
        Args:
            interface: Network interface to use (optional)
        """
        self.interface = interface
        self.running = False
        self.results = []
        self.progress = 0
        self.start_time = None
        self.end_time = None
        self.attack_thread = None
        self.status_callback = None
        
    @abstractmethod
    def start(self, *args, **kwargs):
        """Start the attack (must be implemented by subclass)"""
        pass
    
    def stop(self):
        """Stop the attack"""
        self.running = False
        self.end_time = time.time()
        
    def run_in_thread(self, target_func, *args, **kwargs):
        """Run attack in separate thread"""
        self.attack_thread = threading.Thread(
            target=target_func,
            args=args,
            kwargs=kwargs,
            daemon=True
        )
        self.attack_thread.start()
        
    def get_status(self):
        """Get current attack status"""
        return {
            'running': self.running,
            'progress': self.progress,
            'results_count': len(self.results),
            'duration': (time.time() - self.start_time) if self.start_time else 0,
            'interface': self.interface
        }
    
    def add_result(self, result):
        """Add a result to the results list"""
        result['timestamp'] = time.time()
        self.results.append(result)
        if self.status_callback:
            self.status_callback(result)
    
    def clear_results(self):
        """Clear all results"""
        self.results = []
        
    def set_status_callback(self, callback):
        """Set callback for status updates"""
        self.status_callback = callback
    
    def format_results(self):
        """Format results for display"""
        if not self.results:
            return "No results yet"
        
        output = []
        for i, result in enumerate(self.results, 1):
            output.append(f"Result {i}:")
            for key, value in result.items():
                if key != 'timestamp':
                    output.append(f"  {key}: {value}")
            output.append("")
        
        return "\n".join(output)


class AttackStatistics:
    """Helper class for attack statistics"""
    
    def __init__(self):
        self.reset()
        
    def reset(self):
        self.packets_captured = 0
        self.ivs_captured = 0
        self.weak_ivs_found = 0
        self.keys_tested = 0
        self.start_time = None
        
    def start(self):
        self.start_time = time.time()
        
    def get_stats(self):
        elapsed = time.time() - self.start_time if self.start_time else 0
        return {
            'packets_captured': self.packets_captured,
            'ivs_captured': self.ivs_captured,
            'weak_ivs_found': self.weak_ivs_found,
            'keys_tested': self.keys_tested,
            'elapsed_time': elapsed,
            'packets_per_second': self.packets_captured / elapsed if elapsed > 0 else 0
        }
