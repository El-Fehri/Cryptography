"""
Network Scanning Module
Real WiFi Scanner using system commands
Educational Purpose Only
"""

import subprocess
import re
import random
import time
import threading
from collections import defaultdict


class NetworkScanner:
    """Real WiFi network scanner using system commands"""
    
    def __init__(self):
        self.networks = []
        self.clients = []  # Will be empty for real scanning (client detection is complex)
        self.scanning = False
        self.scan_thread = None
        self.scan_callbacks = []
        self.interface = self._get_wifi_interface()
        self.packets_captured = 0
        
    def _get_wifi_interface(self):
        """Get the WiFi interface name"""
        try:
            # Try to find wlan interface
            result = subprocess.run(['iwconfig'], capture_output=True, text=True)
            lines = result.stdout.split('\n')
            for line in lines:
                if 'IEEE 802.11' in line:
                    # Extract interface name (first word)
                    interface = line.split()[0]
                    return interface
        except:
            pass
        return 'wlan0'  # Default guess
    
    def _execute_scan(self):
        """Execute WiFi scan using iwlist"""
        networks = []
        
        try:
            # Use iwlist to scan
            result = subprocess.run(
                ['sudo', 'iwlist', self.interface, 'scan'], 
                capture_output=True, 
                text=True
            )
            
            if result.returncode != 0:
                print(f"Scan failed: {result.stderr}")
                return networks
            
            # Parse the output
            cells = result.stdout.split('Cell ')
            
            for cell in cells[1:]:  # Skip the first empty split
                network = self._parse_cell(cell)
                if network:
                    networks.append(network)
                    
        except Exception as e:
            print(f"Error scanning: {e}")
            
        return networks
    
    def _parse_cell(self, cell_text):
        """Parse a single cell/network from iwlist output"""
        network = {}
        
        # Extract MAC address (BSSID)
        mac_match = re.search(r'Address: ([0-9A-Fa-f:]{17})', cell_text)
        if mac_match:
            network['bssid'] = mac_match.group(1).upper()
        
        # Extract SSID
        ssid_match = re.search(r'ESSID:"([^"]*)"', cell_text)
        if ssid_match:
            network['ssid'] = ssid_match.group(1)
        else:
            network['ssid'] = '<Hidden SSID>'
        
        # Extract channel
        channel_match = re.search(r'Channel:(\d+)', cell_text)
        if channel_match:
            network['channel'] = int(channel_match.group(1))
        else:
            # Try to get from Frequency
            freq_match = re.search(r'Frequency:[\d\.]+ GHz \(Channel (\d+)\)', cell_text)
            if freq_match:
                network['channel'] = int(freq_match.group(1))
            else:
                network['channel'] = 0
        
        # Extract signal quality/strength
        signal_match = re.search(r'Quality[=:](\d+)/(\d+)', cell_text)
        if signal_match:
            quality = int(signal_match.group(1))
            max_quality = int(signal_match.group(2))
            # Convert to dBm approximation
            network['signal'] = -100 + int((quality / max_quality) * 50)
        else:
            # Try to get signal level directly
            level_match = re.search(r'Signal level[=:](-?\d+) dBm', cell_text)
            if level_match:
                network['signal'] = int(level_match.group(1))
            else:
                network['signal'] = -100
        
        # Extract encryption
        if 'Encryption key:on' in cell_text:
            if 'WPA2' in cell_text and 'WPA3' in cell_text:
                network['encryption'] = 'WPA2/WPA3 Mixed'
            elif 'WPA3' in cell_text:
                network['encryption'] = 'WPA3'
            elif 'WPA2' in cell_text:
                network['encryption'] = 'WPA2'
            elif 'WPA' in cell_text:
                network['encryption'] = 'WPA'
            elif 'WEP' in cell_text:
                network['encryption'] = 'WEP'
            else:
                network['encryption'] = 'Unknown'
        else:
            network['encryption'] = 'OPEN'
        
        # We don't get client count from scan
        network['clients'] = 0
        
        # Add timestamp
        network['first_seen'] = time.time()
        network['last_seen'] = time.time()
        
        return network if 'bssid' in network else None
    
    def _scan_with_nmcli(self):
        """Alternative scan using nmcli (NetworkManager)"""
        networks = []
        
        try:
            # Use nmcli to scan - with better field formatting
            result = subprocess.run(
                ['nmcli', '--fields', 'SSID,BSSID,CHAN,SECURITY,SIGNAL', 'dev', 'wifi', 'list'],
                capture_output=True,
                text=True
            )
            
            if result.returncode != 0:
                return networks
            
            # Skip header line
            lines = result.stdout.strip().split('\n')[1:]
            
            for line in lines:
                if not line.strip():
                    continue
                
                # Parse the line - nmcli output can be tricky
                parts = line.split()
                if len(parts) < 5:
                    continue
                
                # Extract BSSID (usually the second field)
                bssid = None
                ssid = []
                channel = 0
                security = "OPEN"
                signal = 0
                
                # Try to parse intelligently
                # Format is usually: SSID BSSID CHAN SECURITY SIGNAL
                current_pos = 0
                
                # SSID might contain spaces, so we need to find BSSID pattern
                for i, part in enumerate(parts):
                    if re.match(r'([0-9A-F]{2}:){5}[0-9A-F]{2}', part.upper()):
                        # Found BSSID
                        bssid = part.upper()
                        ssid = ' '.join(parts[:i])
                        
                        # Remaining parts after BSSID
                        remaining = parts[i+1:]
                        if len(remaining) >= 3:
                            try:
                                channel = int(remaining[0])
                            except:
                                channel = 0
                            
                            security = remaining[1]
                            
                            try:
                                signal = int(remaining[2])
                            except:
                                signal = 0
                        break
                
                if bssid and ssid:
                    network = {
                        'ssid': ssid,
                        'bssid': bssid,
                        'channel': channel,
                        'encryption': security if security else 'OPEN',
                        'signal': signal,
                        'clients': 0,
                        'first_seen': time.time(),
                        'last_seen': time.time()
                    }
                    networks.append(network)
                            
        except Exception as e:
            print(f"nmcli scan failed: {e}")
            
        return networks
    
    def _scan_fallback_simulated(self):
        """Fallback simulated scan when real scanning fails"""
        networks = []
        
        # Common SSIDs for simulation
        ssids = [
            "Home Network", "WiFi-2.4G", "NETGEAR68", "Linksys", "ATT-WiFi",
            "Starbucks", "Airport WiFi", "Hotel WiFi", "Guest Network",
            "iPhone", "AndroidAP", "TP-Link_1234", "D-Link", "ASUS"
        ]
        
        encryptions = ["WPA2", "WPA2", "WPA2", "WPA3", "WEP", "OPEN", "WPA2/WPA3 Mixed"]
        
        for i in range(8):  # Generate 8 simulated networks
            network = {
                'bssid': ':'.join([f'{random.randint(0,255):02X}' for _ in range(6)]),
                'ssid': f"{random.choice(ssids)} {random.randint(1,999)}",
                'channel': random.choice([1, 6, 11, 36, 40, 44, 48, 149, 153, 157]),
                'encryption': random.choice(encryptions),
                'signal': random.randint(-85, -30),
                'clients': random.randint(0, 15),
                'first_seen': time.time(),
                'last_seen': time.time()
            }
            networks.append(network)
        
        return networks
    
    def start_scan(self, duration=None, channels=None, callback=None):
        """
        Start real WiFi scanning
        
        Args:
            duration: Scan duration in seconds (None for continuous)
            channels: Ignored for real scanning
            callback: Function to call when networks are found
        """
        self.scanning = True
        self.networks = []  # Clear previous networks
        
        if callback:
            self.scan_callbacks.append(callback)
        
        self.scan_thread = threading.Thread(
            target=self._scan_networks,
            args=(duration,),
            daemon=True
        )
        self.scan_thread.start()
        
        return True
    
    def stop_scan(self):
        """Stop network scanning"""
        self.scanning = False
        if self.scan_thread:
            self.scan_thread.join(timeout=2)
    
    def _scan_networks(self, duration):
        """Continuous scanning loop with fallback"""
        start_time = time.time()
        scan_count = 0
        
        # Check which scanning methods work
        use_nmcli = self._check_nmcli()
        use_iwlist = self._check_iwlist()
        use_fallback = True  # Always have fallback
        
        print(f"Scan methods available: nmcli={use_nmcli}, iwlist={use_iwlist}")
        
        while self.scanning:
            if duration and (time.time() - start_time) > duration:
                break
            
            scan_count += 1
            new_networks = []
            
            # Try real scanning first
            if use_nmcli and scan_count % 2 == 0:
                new_networks = self._scan_with_nmcli()
                if new_networks:
                    use_fallback = False
            
            if not new_networks and use_iwlist:
                new_networks = self._execute_scan()
                if new_networks:
                    use_fallback = False
            
            # Use fallback if no real networks found and we're in fallback mode
            if not new_networks and use_fallback:
                if scan_count % 3 == 0:  # Generate new simulated networks periodically
                    new_networks = self._scan_fallback_simulated()
            
            # Process results
            for network in new_networks:
                self._update_or_add_network(network)
            
            # Notify callbacks about all networks periodically
            if scan_count % 2 == 0:  # Every other scan
                for network in self.networks:
                    for callback in self.scan_callbacks:
                        try:
                            callback('network', network)
                        except Exception as e:
                            print(f"Callback error: {e}")
        
        # Wait before next scan
        time.sleep(2)
    
    def _check_nmcli(self):
        """Check if nmcli is available"""
        try:
            result = subprocess.run(['which', 'nmcli'], capture_output=True)
            return result.returncode == 0
        except:
            return False
        
    def _check_iwlist(self):
        """Check if iwlist is available"""
        try:
            result = subprocess.run(['which', 'iwlist'], capture_output=True)
            return result.returncode == 0
        except:
            return False
    
    def _update_or_add_network(self, new_network):
        """Update existing network or add new one"""
        bssid = new_network['bssid']
        
        # Find existing network
        for i, network in enumerate(self.networks):
            if network['bssid'] == bssid:
                # Update existing
                self.networks[i]['ssid'] = new_network['ssid']
                self.networks[i]['channel'] = new_network['channel']
                self.networks[i]['encryption'] = new_network['encryption']
                self.networks[i]['signal'] = new_network['signal']
                self.networks[i]['last_seen'] = time.time()
                self.packets_captured += 1
                return
        
        # Add new network
        self.networks.append(new_network)
        self.packets_captured += 1
    
    def get_networks_by_encryption(self, encryption_type):
        """Get networks filtered by encryption type"""
        return [n for n in self.networks if n['encryption'] == encryption_type]
    
    def get_network(self, bssid):
        """Get network by BSSID"""
        for network in self.networks:
            if network['bssid'] == bssid:
                return network
        return None
    
    def get_statistics(self):
        """Get scan statistics"""
        encryption_counts = defaultdict(int)
        for network in self.networks:
            enc = network.get('encryption', 'Unknown')
            encryption_counts[enc] += 1
        
        return {
            'total_networks': len(self.networks),
            'total_clients': 0,  # Can't get clients from passive scan
            'packets_captured': self.packets_captured,
            'encryption_breakdown': dict(encryption_counts),
            'scanning': self.scanning
        }
    
    def clear_results(self):
        """Clear all scan results"""
        self.networks.clear()
        self.packets_captured = 0


class WiFiScanner:
    """Alternative scanner using iw dev (newer interface)"""
    
    @staticmethod
    def scan_iw():
        """Scan using iw dev command"""
        networks = []
        
        try:
            # Get interface
            result = subprocess.run(['iw', 'dev'], capture_output=True, text=True)
            interface_match = re.search(r'Interface\s+(\w+)', result.stdout)
            if not interface_match:
                return networks
            
            interface = interface_match.group(1)
            
            # Trigger scan
            subprocess.run(['sudo', 'iw', 'dev', interface, 'scan'], 
                         capture_output=True, timeout=5)
            
            # Get scan results
            result = subprocess.run(
                ['sudo', 'iw', 'dev', interface, 'scan'], 
                capture_output=True, 
                text=True
            )
            
            # Parse BSS entries
            bss_blocks = re.split(r'BSS ', result.stdout)[1:]
            
            for block in bss_blocks:
                network = {}
                
                # BSSID
                bssid_match = re.match(r'([0-9a-f:]{17})', block)
                if bssid_match:
                    network['bssid'] = bssid_match.group(1).upper()
                
                # SSID
                ssid_match = re.search(r'SSID: (.*?)\n', block)
                if ssid_match:
                    network['ssid'] = ssid_match.group(1)
                else:
                    network['ssid'] = '<Hidden>'
                
                # Channel/frequency
                freq_match = re.search(r'freq: (\d+)', block)
                if freq_match:
                    freq = int(freq_match.group(1))
                    # Convert frequency to channel (simplified)
                    if 2412 <= freq <= 2484:
                        network['channel'] = (freq - 2407) // 5
                    elif 5180 <= freq <= 5825:
                        network['channel'] = (freq - 5000) // 5
                    else:
                        network['channel'] = 0
                
                # Signal
                signal_match = re.search(r'signal: (-?\d+)\.\d+ dBm', block)
                if signal_match:
                    network['signal'] = int(signal_match.group(1))
                
                # Encryption (simplified)
                if 'RSN:' in block or 'WPA:' in block:
                    if 'WPA3' in block:
                        network['encryption'] = 'WPA3'
                    elif 'RSN:' in block:
                        network['encryption'] = 'WPA2'
                    else:
                        network['encryption'] = 'WPA'
                else:
                    network['encryption'] = 'OPEN'
                
                network['clients'] = 0
                
                if 'bssid' in network:
                    networks.append(network)
                    
        except Exception as e:
            print(f"iw scan error: {e}")
            
        return networks