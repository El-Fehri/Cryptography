"""
Packet Analysis Utility Module
"""

import binascii
import struct


def analyze_packet(packet):
    """
    Analyze packet and extract useful information
    
    Args:
        packet: Packet dictionary from packet panel
        
    Returns:
        dict: Analysis results
    """
    analysis = {
        'timestamp': packet.get('time', ''),
        'source': packet.get('src', ''),
        'destination': packet.get('dst', ''),
        'protocol': packet.get('protocol', ''),
        'length': packet.get('length', 0),
        'features': []
    }
    
    # Protocol-specific analysis
    if packet['protocol'] == 'WEP':
        analysis.update(analyze_wep_packet(packet))
    elif packet['protocol'] == 'WPA':
        analysis.update(analyze_wpa_packet(packet))
    elif packet['protocol'] == 'Deauth':
        analysis.update(analyze_deauth_packet(packet))
    elif packet['protocol'] == 'Beacon':
        analysis.update(analyze_beacon_packet(packet))
        
    return analysis


def analyze_wep_packet(packet):
    """Analyze WEP packet"""
    raw_data = packet.get('raw', b'')
    analysis = {
        'type': 'WEP Encrypted',
        'iv': None,
        'key_id': None,
        'icv_valid': None
    }
    
    if len(raw_data) >= 4:
        analysis['iv'] = binascii.hexlify(raw_data[:3]).decode().upper()
        analysis['key_id'] = raw_data[3] >> 6
        
        # Check if we have the full packet with ICV
        if len(raw_data) >= 8:
            analysis['icv_present'] = True
            analysis['encrypted_length'] = len(raw_data) - 4
            
    return analysis


def analyze_wpa_packet(packet):
    """Analyze WPA/EAPOL packet"""
    raw_data = packet.get('raw', b'')
    analysis = {
        'type': 'WPA Handshake',
        'handshake_type': None,
        'replay_counter': None
    }
    
    # Simplified EAPOL analysis
    if b'EAPOL' in packet.get('info', ''):
        analysis['handshake_type'] = '4-Way Handshake'
        
    return analysis


def analyze_deauth_packet(packet):
    """Analyze deauthentication packet"""
    raw_data = packet.get('raw', b'')
    analysis = {
        'type': 'Deauthentication',
        'reason_code': None,
        'reason_description': None
    }
    
    # Extract reason code (simplified)
    if 'reason' in packet.get('info', '').lower():
        analysis['reason_code'] = 7
        analysis['reason_description'] = 'Nonassociated station'
        
    return analysis


def analyze_beacon_packet(packet):
    """Analyze beacon frame"""
    raw_data = packet.get('raw', b'')
    analysis = {
        'type': 'Beacon',
        'ssid': None,
        'capabilities': []
    }
    
    # Extract SSID from info (simplified)
    info = packet.get('info', '')
    if 'SSID:' in info:
        try:
            ssid = info.split('SSID:')[1].split()[0]
            analysis['ssid'] = ssid
        except:
            pass
            
    return analysis


def extract_iv(packet_data):
    """
    Extract Initialization Vector from WEP packet
    
    Args:
        packet_data: Raw packet bytes
        
    Returns:
        bytes: 3-byte IV or None if not found
    """
    if len(packet_data) >= 3:
        # First 3 bytes are the IV in WEP
        return packet_data[:3]
    return None


def is_wep_packet(packet):
    """
    Check if packet is WEP encrypted
    
    Args:
        packet: Packet dictionary
        
    Returns:
        bool: True if WEP packet
    """
    return packet.get('protocol') == 'WEP'


def calculate_icv(data):
    """
    Calculate Integrity Check Value (CRC-32)
    
    Args:
        data: Data bytes
        
    Returns:
        bytes: 4-byte ICV
    """
    crc = 0xFFFFFFFF
    for byte in data:
        crc ^= byte
        for _ in range(8):
            if crc & 1:
                crc = (crc >> 1) ^ 0xEDB88320
            else:
                crc >>= 1
    return struct.pack('<I', (~crc) & 0xFFFFFFFF)


def verify_icv(data, received_icv):
    """
    Verify packet ICV
    
    Args:
        data: Packet data (without ICV)
        received_icv: Received ICV bytes
        
    Returns:
        bool: True if ICV matches
    """
    calculated = calculate_icv(data)
    return calculated == received_icv


def parse_mac_address(mac_str):
    """
    Parse MAC address string to bytes
    
    Args:
        mac_str: MAC address string (e.g., "00:11:22:33:44:55")
        
    Returns:
        bytes: 6-byte MAC address
    """
    mac_str = mac_str.replace(':', '').replace('-', '').replace('.', '')
    return bytes.fromhex(mac_str)


def format_mac_address(mac_bytes):
    """
    Format MAC address bytes to string
    
    Args:
        mac_bytes: 6-byte MAC address
        
    Returns:
        str: Formatted MAC address
    """
    return ':'.join([f'{b:02X}' for b in mac_bytes])
