"""
Visualization Panel Module
Provides real-time charts and graphs for data visualization
"""

import tkinter as tk
from tkinter import ttk
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
import numpy as np
from collections import deque
import threading
import time


class VisualizationPanel:
    """Real-time visualization panel for network data and attack progress"""
    
    def __init__(self, parent, main_window):
        self.parent = parent
        self.main = main_window
        
        # Data storage for real-time plots
        self.max_data_points = 50
        self.timestamps = deque(maxlen=self.max_data_points)
        self.packet_rates = deque(maxlen=self.max_data_points)
        self.iv_counts = deque(maxlen=self.max_data_points)
        self.signal_strengths = deque(maxlen=self.max_data_points)
        self.attack_progress = deque(maxlen=self.max_data_points)
        
        # Channel usage data
        self.channel_usage = {i: 0 for i in range(1, 12)}
        
        # Create the visualization
        self.create_widgets()
        
        # Start update timer
        self.update_interval = 1000  # ms
        self.schedule_update()
        
    def create_widgets(self):
        """Create visualization widgets"""
        # Main frame
        self.frame = ttk.LabelFrame(self.parent, text="Real-time Analysis", padding="5")
        
        # Create matplotlib figure with subplots
        self.fig = Figure(figsize=(12, 6), dpi=100, facecolor='#2b2b2b')
        
        # Configure subplots
        self.ax1 = self.fig.add_subplot(231)  # Packet rate
        self.ax2 = self.fig.add_subplot(232)  # IV distribution
        self.ax3 = self.fig.add_subplot(233)  # Channel usage
        self.ax4 = self.fig.add_subplot(234)  # Signal strength
        self.ax5 = self.fig.add_subplot(235)  # Attack progress
        self.ax6 = self.fig.add_subplot(236)  # Encryption breakdown
        
        # Set dark theme for plots
        self.setup_plot_style()
        
        # Create canvas
        self.canvas = FigureCanvasTkAgg(self.fig, master=self.frame)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        
        # Control buttons
        control_frame = ttk.Frame(self.frame)
        control_frame.pack(fill=tk.X, pady=5)
        
        self.pause_btn = ttk.Button(control_frame, text="‚è∏ Pause", 
                                     command=self.toggle_pause, width=10)
        self.pause_btn.pack(side=tk.LEFT, padx=2)
        
        self.reset_btn = ttk.Button(control_frame, text="‚Ü∫ Reset", 
                                     command=self.reset_data, width=10)
        self.reset_btn.pack(side=tk.LEFT, padx=2)
        
        self.export_btn = ttk.Button(control_frame, text="üíæ Export", 
                                      command=self.export_data, width=10)
        self.export_btn.pack(side=tk.LEFT, padx=2)
        
        # View options
        ttk.Label(control_frame, text="Update interval:").pack(side=tk.LEFT, padx=(20,5))
        self.interval_var = tk.IntVar(value=1000)
        interval_spin = ttk.Spinbox(control_frame, from_=100, to=5000, 
                                     textvariable=self.interval_var, width=8)
        interval_spin.pack(side=tk.LEFT, padx=2)
        interval_spin.bind('<Return>', self.change_interval)
        
        self.paused = False
        
    def setup_plot_style(self):
        """Configure dark theme for plots"""
        dark_bg = '#2b2b2b'
        light_text = '#ffffff'
        grid_color = '#3c3f41'
        
        for ax in [self.ax1, self.ax2, self.ax3, self.ax4, self.ax5, self.ax6]:
            ax.set_facecolor(dark_bg)
            ax.tick_params(colors=light_text)
            ax.xaxis.label.set_color(light_text)
            ax.yaxis.label.set_color(light_text)
            ax.title.set_color(light_text)
            ax.grid(True, color=grid_color, linestyle='--', linewidth=0.5)
            
            for spine in ax.spines.values():
                spine.set_color(grid_color)
        
        self.fig.patch.set_facecolor(dark_bg)
        self.fig.tight_layout()
        
    def schedule_update(self):
        """Schedule periodic update"""
        if not self.paused:
            self.update_plots()
        self.frame.after(self.interval_var.get(), self.schedule_update)
        
    def update_plots(self):
        """Update all plots with current data"""
        try:
            self.update_packet_rate_plot()
            self.update_iv_distribution_plot()
            self.update_channel_usage_plot()
            self.update_signal_strength_plot()
            self.update_attack_progress_plot()
            self.update_encryption_breakdown_plot()
            
            self.canvas.draw_idle()
        except Exception as e:
            print(f"Error updating plots: {e}")
            
    def update_packet_rate_plot(self):
        """Update packet rate over time plot"""
        self.ax1.clear()
        self.setup_subplot_style(self.ax1, 'Packet Rate', 'Time (s)', 'Packets/s')
        
        if len(self.timestamps) > 1:
            times = list(self.timestamps)
            rates = list(self.packet_rates)
            self.ax1.plot(times, rates, color='#589df6', linewidth=2, marker='o', markersize=4)
            self.ax1.fill_between(times, rates, alpha=0.3, color='#589df6')
            
            # Add current value
            if rates:
                self.ax1.text(0.02, 0.95, f'Current: {rates[-1]:.0f} pps', 
                             transform=self.ax1.transAxes, color='#ffffff',
                             bbox=dict(facecolor='#3c3f41', alpha=0.8))
        
    def update_iv_distribution_plot(self):
        """Update IV distribution histogram"""
        self.ax2.clear()
        self.setup_subplot_style(self.ax2, 'IV Distribution', 'IV Value', 'Count')
        
        if hasattr(self.main, 'wep_attack') and self.main.wep_attack.wep_core.iv_statistics:
            ivs = list(self.main.wep_attack.wep_core.iv_statistics.keys())
            counts = list(self.main.wep_attack.wep_core.iv_statistics.values())
            
            if ivs:
                # Convert hex IVs to numeric for plotting
                numeric_ivs = [int(iv[:2], 16) for iv in ivs[:20]]  # Use first byte
                self.ax2.bar(range(len(numeric_ivs)), counts[:20], 
                           color='#6a8759', alpha=0.7)
                
                weak_count = len(self.main.wep_attack.wep_core.weak_ivs)
                total = sum(counts)
                if total > 0:
                    self.ax2.text(0.02, 0.95, f'Weak IVs: {weak_count} ({weak_count/total*100:.1f}%)',
                                 transform=self.ax2.transAxes, color='#ac3a3a',
                                 bbox=dict(facecolor='#3c3f41', alpha=0.8))
        
    def update_channel_usage_plot(self):
        """Update channel usage bar chart"""
        self.ax3.clear()
        self.setup_subplot_style(self.ax3, 'Channel Usage', 'Channel', 'Networks')
        
        # Update channel usage from scanner
        if hasattr(self.main, 'scanner'):
            self.channel_usage = {i: 0 for i in range(1, 12)}
            for network in self.main.scanner.networks:
                ch = network.get('channel', 1)
                if 1 <= ch <= 11:
                    self.channel_usage[ch] += 1
        
        channels = list(self.channel_usage.keys())
        counts = list(self.channel_usage.values())
        
        bars = self.ax3.bar(channels, counts, color='#cc7832', alpha=0.7)
        
        # Color the most used channel
        if counts:
            max_count = max(counts)
            for bar, count in zip(bars, counts):
                if count == max_count and count > 0:
                    bar.set_color('#ac3a3a')
                    
    def update_signal_strength_plot(self):
        """Update signal strength over time"""
        self.ax4.clear()
        self.setup_subplot_style(self.ax4, 'Signal Strength', 'Time (s)', 'dBm')
        
        if len(self.signal_strengths) > 1:
            times = list(self.timestamps)[-len(self.signal_strengths):]
            signals = list(self.signal_strengths)
            self.ax4.plot(times, signals, color='#9876aa', linewidth=2)
            
            # Add threshold line
            self.ax4.axhline(y=-80, color='#ac3a3a', linestyle='--', alpha=0.5, label='Poor signal')
            self.ax4.axhline(y=-50, color='#6a8759', linestyle='--', alpha=0.5, label='Good signal')
            self.ax4.legend(loc='upper right', facecolor='#2b2b2b', labelcolor='#ffffff')
            
    def update_attack_progress_plot(self):
        """Update attack progress over time"""
        self.ax5.clear()
        self.setup_subplot_style(self.ax5, 'Attack Progress', 'Time (s)', 'Progress %')
        
        if len(self.attack_progress) > 1:
            times = list(self.timestamps)[-len(self.attack_progress):]
            progress = list(self.attack_progress)
            self.ax5.plot(times, progress, color='#6a8759', linewidth=3)
            self.ax5.set_ylim(0, 100)
            
            # Add current progress
            if progress:
                self.ax5.text(0.02, 0.95, f'{progress[-1]:.1f}% complete',
                             transform=self.ax5.transAxes, color='#ffffff',
                             bbox=dict(facecolor='#3c3f41', alpha=0.8))
                
    def update_encryption_breakdown_plot(self):
        """Update encryption type pie chart"""
        self.ax6.clear()
        self.ax6.set_title('Encryption Breakdown', color='#ffffff')
        
        if hasattr(self.main, 'scanner') and self.main.scanner.networks:
            enc_counts = {}
            for network in self.main.scanner.networks:
                enc = network.get('encryption', 'Unknown')
                enc_counts[enc] = enc_counts.get(enc, 0) + 1
            
            if enc_counts:
                labels = list(enc_counts.keys())
                sizes = list(enc_counts.values())
                colors = ['#ac3a3a', '#6a8759', '#589df6', '#cc7832', '#9876aa']
                
                wedges, texts, autotexts = self.ax6.pie(
                    sizes, labels=labels, autopct='%1.1f%%',
                    colors=colors[:len(labels)],
                    textprops={'color': '#ffffff'}
                )
                
                # Make autopct text more readable
                for autotext in autotexts:
                    autotext.set_color('#000000')
                    autotext.set_fontweight('bold')
        
    def setup_subplot_style(self, ax, title, xlabel, ylabel):
        """Apply consistent styling to subplot"""
        ax.set_title(title, color='#ffffff', fontsize=10)
        ax.set_xlabel(xlabel, color='#ffffff', fontsize=8)
        ax.set_ylabel(ylabel, color='#ffffff', fontsize=8)
        ax.tick_params(colors='#ffffff', labelsize=7)
        
    def add_data_point(self, packet_rate=None, iv_count=None, signal=None, progress=None):
        """Add a new data point for real-time plots"""
        current_time = time.time()
        if not self.timestamps or current_time > (self.timestamps[-1] + 1):
            self.timestamps.append(current_time)
            
            if packet_rate is not None:
                self.packet_rates.append(packet_rate)
            else:
                self.packet_rates.append(0)
                
            if iv_count is not None:
                self.iv_counts.append(iv_count)
                
            if signal is not None:
                self.signal_strengths.append(signal)
            elif hasattr(self.main, 'network_panel') and self.main.network_panel.network_tree.get_children():
                # Get average signal from networks
                signals = []
                for item in self.main.network_panel.network_tree.get_children()[:5]:
                    values = self.main.network_panel.network_tree.item(item)['values']
                    if len(values) > 4:
                        try:
                            signal_str = values[4].replace(' dBm', '')
                            signals.append(int(signal_str))
                        except:
                            pass
                if signals:
                    self.signal_strengths.append(sum(signals) / len(signals))
                    
            if progress is not None:
                self.attack_progress.append(progress)
            elif hasattr(self.main, 'attack_panel'):
                # Get progress from current attack
                if hasattr(self.main, 'wep_attack'):
                    status = self.main.wep_attack.get_status()
                    if status['running']:
                        self.attack_progress.append(status['progress'])
                        
    def toggle_pause(self):
        """Toggle real-time updates"""
        self.paused = not self.paused
        self.pause_btn.config(text="‚ñ∂ Resume" if self.paused else "‚è∏ Pause")
        
    def reset_data(self):
        """Reset all data collections"""
        self.timestamps.clear()
        self.packet_rates.clear()
        self.iv_counts.clear()
        self.signal_strengths.clear()
        self.attack_progress.clear()
        self.channel_usage = {i: 0 for i in range(1, 12)}
        
    def change_interval(self, event=None):
        """Change update interval"""
        # Validation handled by spinbox
        pass
        
    def export_data(self):
        """Export visualization data to file"""
        from tkinter import filedialog
        import json
        
        filename = filedialog.asksaveasfilename(
            title="Export Visualization Data",
            defaultextension=".json",
            filetypes=[("JSON files", "*.json"), ("CSV files", "*.csv")]
        )
        
        if filename:
            data = {
                'timestamps': list(self.timestamps),
                'packet_rates': list(self.packet_rates),
                'iv_counts': list(self.iv_counts),
                'signal_strengths': list(self.signal_strengths),
                'attack_progress': list(self.attack_progress),
                'channel_usage': self.channel_usage
            }
            
            try:
                with open(filename, 'w') as f:
                    json.dump(data, f, indent=2)
                self.main.log(f"Visualization data exported to {filename}")
            except Exception as e:
                self.main.log(f"Error exporting data: {e}")
                
    def pack(self, *args, **kwargs):
        """Pack the frame"""
        self.frame.pack(*args, **kwargs)
        
    def pack_forget(self):
        """Hide the frame"""
        self.frame.pack_forget()
