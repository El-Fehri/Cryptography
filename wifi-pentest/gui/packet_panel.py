"""
Packet Capture and Analysis Panel Module
"""

import tkinter as tk
from tkinter import ttk
import binascii
import time
from datetime import datetime


class PacketPanel:
    """Packet capture and analysis panel"""
    
    def __init__(self, parent, main_window):
        self.parent = parent
        self.main = main_window
        self.packets = []
        self.capturing = False
        
        self.create_widgets()
        
    def create_widgets(self):
        """Create packet panel widgets"""
        # Main frame
        main_frame = ttk.Frame(self.parent)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Control frame
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill=tk.X, pady=5)
        
        self.capture_btn = ttk.Button(control_frame, text="â–¶ Start Capture", 
                                       command=self.toggle_capture, width=15)
        self.capture_btn.pack(side=tk.LEFT, padx=2)
        
        ttk.Button(control_frame, text="ðŸ—‘ Clear", 
                  command=self.clear_packets, width=8).pack(side=tk.LEFT, padx=2)
        
        ttk.Button(control_frame, text="ðŸ’¾ Save", 
                  command=self.save_packets, width=8).pack(side=tk.LEFT, padx=2)
        
        # Filter frame
        filter_frame = ttk.Frame(main_frame)
        filter_frame.pack(fill=tk.X, pady=2)
        
        ttk.Label(filter_frame, text="Filter:").pack(side=tk.LEFT)
        self.filter_var = tk.StringVar()
        self.filter_combo = ttk.Combobox(filter_frame, textvariable=self.filter_var,
                                        values=['All', 'WEP', 'WPA', 'Beacon', 'Data', 'Auth', 'Deauth'],
                                        width=10, state='readonly')
        self.filter_combo.set('All')
        self.filter_combo.pack(side=tk.LEFT, padx=5)
        self.filter_combo.bind('<<ComboboxSelected>>', self.apply_filter)
        
        # Search frame
        search_frame = ttk.Frame(main_frame)
        search_frame.pack(fill=tk.X, pady=2)
        
        ttk.Label(search_frame, text="Search:").pack(side=tk.LEFT)
        self.search_var = tk.StringVar()
        self.search_entry = ttk.Entry(search_frame, textvariable=self.search_var, width=15)
        self.search_entry.pack(side=tk.LEFT, padx=5)
        self.search_entry.bind('<KeyRelease>', self.search_packets)
        
        # Packet list with scrollbars
        list_frame = ttk.Frame(main_frame)
        list_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Create treeview
        columns = ('#', 'Time', 'Source', 'Dest', 'Protocol', 'Info', 'Length')
        self.packet_tree = ttk.Treeview(list_frame, columns=columns, show='headings', height=15)
        
        # Define columns
        column_widths = {'#': 50, 'Time': 80, 'Source': 120, 'Dest': 120, 
                        'Protocol': 80, 'Info': 200, 'Length': 60}
        
        for col in columns:
            self.packet_tree.heading(col, text=col)
            self.packet_tree.column(col, width=column_widths.get(col, 80))
        
        # Add scrollbars
        v_scroll = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, command=self.packet_tree.yview)
        h_scroll = ttk.Scrollbar(list_frame, orient=tk.HORIZONTAL, command=self.packet_tree.xview)
        self.packet_tree.configure(yscrollcommand=v_scroll.set, xscrollcommand=h_scroll.set)
        
        # Grid layout
        self.packet_tree.grid(row=0, column=0, sticky='nsew')
        v_scroll.grid(row=0, column=1, sticky='ns')
        h_scroll.grid(row=1, column=0, sticky='ew')
        
        list_frame.grid_rowconfigure(0, weight=1)
        list_frame.grid_columnconfigure(0, weight=1)
        
        # Bind selection event
        self.packet_tree.bind('<<TreeviewSelect>>', self.on_packet_select)
        self.packet_tree.bind('<Double-Button-1>', self.on_packet_double_click)
        
        # Packet details frame
        details_frame = ttk.LabelFrame(main_frame, text="Packet Details", padding="5")
        details_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Create notebook for different views
        self.details_notebook = ttk.Notebook(details_frame)
        self.details_notebook.pack(fill=tk.BOTH, expand=True)
        
        # Hex view tab
        self.hex_frame = ttk.Frame(self.details_notebook)
        self.details_notebook.add(self.hex_frame, text="Hex View")
        
        self.hex_text = tk.Text(self.hex_frame, wrap=tk.NONE, font=('Courier', 9),
                                bg='#2b2b2b', fg='#a9b7c6', height=8)
        self.hex_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        hex_scroll = ttk.Scrollbar(self.hex_frame, orient=tk.VERTICAL, command=self.hex_text.yview)
        hex_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        self.hex_text.configure(yscrollcommand=hex_scroll.set)
        
        # ASCII view tab
        self.ascii_frame = ttk.Frame(self.details_notebook)
        self.details_notebook.add(self.ascii_frame, text="ASCII View")
        
        self.ascii_text = tk.Text(self.ascii_frame, wrap=tk.WORD, font=('Courier', 9),
                                  bg='#2b2b2b', fg='#a9b7c6', height=8)
        self.ascii_text.pack(fill=tk.BOTH, expand=True)
        
        # Info tab
        self.info_frame = ttk.Frame(self.details_notebook)
        self.details_notebook.add(self.info_frame, text="Information")
        
        self.info_text = tk.Text(self.info_frame, wrap=tk.WORD, font=('Arial', 9),
                                 bg='#2b2b2b', fg='#a9b7c6', height=8)
        self.info_text.pack(fill=tk.BOTH, expand=True)
        
        # Statistics frame
        stats_frame = ttk.Frame(main_frame)
        stats_frame.pack(fill=tk.X, pady=2)
        
        self.stats_label = ttk.Label(stats_frame, text="Packets: 0 | WEP: 0 | WPA: 0 | Data: 0",
                                     style='Info.TLabel')
        self.stats_label.pack()
        
    def toggle_capture(self):
        """Toggle packet capture"""
        self.capturing = not self.capturing
        if self.capturing:
            self.capture_btn.config(text="â¹ Stop Capture")
            self.start_capture()
        else:
            self.capture_btn.config(text="â–¶ Start Capture")
            self.main.log("Packet capture stopped")
            
    def start_capture(self):
        """Start packet capture simulation"""
        self.main.log("Starting packet capture...")
        
        def capture_loop():
            while self.capturing:
                # Simulate packet capture
                packet = self.generate_packet()
                self.main.message_queue.put({
                    'type': 'packet_captured',
                    'data': packet
                })
                # Update visualization
                self.main.viz_panel.add_data_point(
                    packet_rate=len(self.packets) / max(1, time.time() - self.start_time),
                    iv_count=len([p for p in self.packets if 'IV' in str(p)])
                )
                time.sleep(0.5)  # Simulate capture rate
                
        self.start_time = time.time()
        import threading
        threading.Thread(target=capture_loop, daemon=True).start()
        
    def generate_packet(self):
        """Generate a simulated packet"""
        packet_types = [
            ('Beacon', '802.11 Beacon frame'),
            ('Data', 'QoS Data'),
            ('WEP', 'WEP encrypted data'),
            ('WPA', 'EAPOL Key'),
            ('Auth', 'Authentication'),
            ('Deauth', 'Deauthentication'),
            ('Probe', 'Probe Request'),
            ('ACK', 'Acknowledgement'),
        ]
        
        pkt_type, pkt_info = random.choice(packet_types)
        
        # Generate random MAC addresses
        src_mac = ':'.join([f'{random.randint(0,255):02X}' for _ in range(6)])
        dst_mac = ':'.join([f'{random.randint(0,255):02X}' for _ in range(6)])
        
        # Generate random data
        data = os.urandom(random.randint(20, 100))
        
        packet = {
            'time': datetime.now().strftime('%H:%M:%S.%f')[:-3],
            'src': src_mac,
            'dst': dst_mac,
            'protocol': pkt_type,
            'info': f"{pkt_info} (seq: {random.randint(0,4095)})",
            'length': len(data),
            'raw': data,
            'iv': data[:3] if pkt_type == 'WEP' else None
        }
        
        self.packets.append(packet)
        return packet
        
    def add_packet(self, packet):
        """Add a packet to the display"""
        item_id = self.packet_tree.insert('', 'end', values=(
            len(self.packets),
            packet['time'],
            packet['src'],
            packet['dst'],
            packet['protocol'],
            packet['info'][:40] + '...' if len(packet['info']) > 40 else packet['info'],
            packet['length']
        ))
        
        # Color code by protocol
        protocol = packet['protocol']
        if protocol == 'WEP':
            self.packet_tree.tag_configure('wep', background='#5a3a3a')
            self.packet_tree.item(item_id, tags=('wep',))
        elif protocol == 'WPA':
            self.packet_tree.tag_configure('wpa', background='#3a3a5a')
            self.packet_tree.item(item_id, tags=('wpa',))
        elif protocol == 'Deauth':
            self.packet_tree.tag_configure('deauth', background='#5a3a3a')
            self.packet_tree.item(item_id, tags=('deauth',))
        elif protocol == 'Beacon':
            self.packet_tree.tag_configure('beacon', background='#3a5a3a')
            self.packet_tree.item(item_id, tags=('beacon',))
            
        self.update_statistics()
        
    def on_packet_select(self, event):
        """Handle packet selection"""
        selection = self.packet_tree.selection()
        if selection:
            item = self.packet_tree.item(selection[0])
            packet_idx = int(item['values'][0]) - 1
            if 0 <= packet_idx < len(self.packets):
                self.show_packet_details(self.packets[packet_idx])
                
    def on_packet_double_click(self, event):
        """Handle double-click on packet"""
        selection = self.packet_tree.selection()
        if selection:
            item = self.packet_tree.item(selection[0])
            packet_idx = int(item['values'][0]) - 1
            if 0 <= packet_idx < len(self.packets):
                self.show_packet_analysis(self.packets[packet_idx])
                
    def show_packet_details(self, packet):
        """Show detailed packet information"""
        # Clear previous content
        self.hex_text.delete(1.0, tk.END)
        self.ascii_text.delete(1.0, tk.END)
        self.info_text.delete(1.0, tk.END)
        
        # Hex view
        raw_data = packet.get('raw', b'')
        hex_lines = []
        ascii_lines = []
        
        for i in range(0, len(raw_data), 16):
            chunk = raw_data[i:i+16]
            hex_str = ' '.join([f'{b:02x}' for b in chunk])
            ascii_str = ''.join([chr(b) if 32 <= b <= 126 else '.' for b in chunk])
            hex_lines.append(f'{i:04x}: {hex_str:<48} {ascii_str}')
            
        self.hex_text.insert(tk.END, '\n'.join(hex_lines))
        
        # ASCII view
        ascii_text = ''.join([chr(b) if 32 <= b <= 126 else '.' for b in raw_data])
        self.ascii_text.insert(tk.END, ascii_text)
        
        # Info view
        info_lines = [
            "Packet Information:",
            "=" * 50,
            f"Timestamp: {packet['time']}",
            f"Source MAC: {packet['src']}",
            f"Destination MAC: {packet['dst']}",
            f"Protocol: {packet['protocol']}",
            f"Length: {packet['length']} bytes",
            f"Info: {packet['info']}",
            "",
            "Analysis:",
            "=" * 50,
        ]
        
        # Add protocol-specific analysis
        if packet['protocol'] == 'WEP':
            info_lines.extend([
                "WEP Encrypted Packet:",
                f"  IV: {binascii.hexlify(packet.get('iv', b'')).decode() if packet.get('iv') else 'Unknown'}",
                "  Key ID: 0",
                "  ICV: Present (4 bytes)",
                "",
                "Security Note: WEP is vulnerable to various attacks",
                "due to weak IV implementation and RC4 weaknesses."
            ])
        elif packet['protocol'] == 'WPA':
            info_lines.extend([
                "WPA EAPOL Key Frame:",
                "  Key Descriptor: AES",
                "  Key Information: Pairwise Key",
                "  Replay Counter: Present",
                "",
                "This packet is part of the 4-way handshake.",
                "Can be used for dictionary attacks."
            ])
        elif packet['protocol'] == 'Deauth':
            info_lines.extend([
                "Deauthentication Frame:",
                "  Reason Code: 7 (Nonassociated station)",
                "",
                "This packet can be used to disconnect clients",
                "from the network."
            ])
            
        self.info_text.insert(tk.END, '\n'.join(info_lines))
        
    def show_packet_analysis(self, packet):
        """Show advanced packet analysis"""
        from ..utils.packet_utils import analyze_packet
        
        analysis = analyze_packet(packet)
        
        # Create analysis window
        from .dialogs.packet_analysis import PacketAnalysisDialog
        PacketAnalysisDialog(self.parent, packet, analysis)
        
    def apply_filter(self, event=None):
        """Apply filter to packet list"""
        filter_text = self.filter_var.get()
        
        # Clear current items
        for item in self.packet_tree.get_children():
            self.packet_tree.delete(item)
            
        # Re-add filtered packets
        for i, packet in enumerate(self.packets, 1):
            if filter_text == 'All' or packet['protocol'] == filter_text:
                self.packet_tree.insert('', 'end', values=(
                    i,
                    packet['time'],
                    packet['src'],
                    packet['dst'],
                    packet['protocol'],
                    packet['info'][:40] + '...' if len(packet['info']) > 40 else packet['info'],
                    packet['length']
                ))
                
    def search_packets(self, event=None):
        """Search packets for text"""
        search_term = self.search_var.get().lower()
        
        if not search_term:
            self.apply_filter()  # Reset to current filter
            return
            
        # Clear current items
        for item in self.packet_tree.get_children():
            self.packet_tree.delete(item)
            
        # Search and add matching packets
        for i, packet in enumerate(self.packets, 1):
            if (search_term in packet['src'].lower() or
                search_term in packet['dst'].lower() or
                search_term in packet['protocol'].lower() or
                search_term in packet['info'].lower()):
                
                self.packet_tree.insert('', 'end', values=(
                    i,
                    packet['time'],
                    packet['src'],
                    packet['dst'],
                    packet['protocol'],
                    packet['info'][:40] + '...' if len(packet['info']) > 40 else packet['info'],
                    packet['length']
                ))
                
    def clear_packets(self):
        """Clear all packets"""
        self.packets.clear()
        for item in self.packet_tree.get_children():
            self.packet_tree.delete(item)
        self.hex_text.delete(1.0, tk.END)
        self.ascii_text.delete(1.0, tk.END)
        self.info_text.delete(1.0, tk.END)
        self.update_statistics()
        self.main.log("Packet capture cleared")
        
    def save_packets(self):
        """Save packets to file"""
        from tkinter import filedialog
        import json
        
        filename = filedialog.asksaveasfilename(
            title="Save Packets",
            defaultextension=".pcap",
            filetypes=[("PCAP files", "*.pcap"), ("JSON files", "*.json"), ("All files", "*.*")]
        )
        
        if filename:
            try:
                if filename.endswith('.json'):
                    # Save as JSON
                    with open(filename, 'w') as f:
                        json.dump(self.packets, f, indent=2, default=str)
                else:
                    # Simulate PCAP save
                    with open(filename, 'wb') as f:
                        for packet in self.packets:
                            f.write(packet.get('raw', b''))
                            
                self.main.log(f"Saved {len(self.packets)} packets to {filename}")
            except Exception as e:
                self.main.log(f"Error saving packets: {e}")
                
    def update_statistics(self):
        """Update statistics display"""
        total = len(self.packets)
        wep = len([p for p in self.packets if p['protocol'] == 'WEP'])
        wpa = len([p for p in self.packets if p['protocol'] == 'WPA'])
        data = len([p for p in self.packets if p['protocol'] == 'Data'])
        
        self.stats_label.config(
            text=f"Packets: {total} | WEP: {wep} | WPA: {wpa} | Data: {data}"
        )
        
        # Update main window status
        self.main.update_status({'packets': total})
        
    def get_packet_count(self):
        """Get total packet count"""
        return len(self.packets) if hasattr(self, 'packets') else 0

    def get_packets(self):
        """Get all packets"""
        return self.packets if hasattr(self, 'packets') else []
        
    def clear_all(self):
        """Clear all panel data"""
        self.clear_packets()


# Add missing imports
import random
import os
