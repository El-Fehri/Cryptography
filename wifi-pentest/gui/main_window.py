"""
Main Application Window Module
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import threading
import queue
from datetime import datetime

# Absolute imports
from gui.styles import configure_styles
from scanners.network_scanner import NetworkScanner
from attacks.wep_attacks import WEPAttack
from attacks.wpa_attacks import WPAAttack
from attacks.deauth_attack import DeauthAttack


class MainWindow:
    """Main application window"""
    
    def __init__(self, root):
        self.root = root
        self.root.title("Professional WiFi Penetration Testing Framework")
        self.root.geometry("1400x900")
        
        # Set minimum window size
        self.root.minsize(1000, 700)
        
        # Initialize modules
        self.scanner = NetworkScanner()
        self.wep_attack = WEPAttack()
        self.wpa_attack = WPAAttack()
        self.deauth_attack = DeauthAttack()
        
        # Message queue for thread-safe GUI updates
        self.message_queue = queue.Queue()
        
        # Current target
        self.current_target = None
        
        # Configure styles
        self.colors = configure_styles()
        
        # Create GUI
        self.create_menu()
        self.create_main_layout()
        self.create_status_bar()
        
        # Start message processor
        self.process_messages()
        
        # Set up close handler
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
        
        # Log initialization
        self.log("WiFi Penetration Testing Framework initialized")
        self.log("Educational Purpose Only - For Classroom Use")
        self.log("=" * 60)
        
    def create_menu(self):
        """Create main menu bar"""
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)
        
        # File menu
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="File", menu=file_menu)
        file_menu.add_command(label="New Session", command=self.new_session)
        file_menu.add_command(label="Load Session", command=self.load_session)
        file_menu.add_command(label="Save Session", command=self.save_session)
        file_menu.add_separator()
        file_menu.add_command(label="Export Results", command=self.export_results)
        file_menu.add_command(label="Import Capture", command=self.import_capture)
        file_menu.add_separator()
        file_menu.add_command(label="Exit", command=self.on_closing)
        
        # Help menu
        help_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Help", menu=help_menu)
        help_menu.add_command(label="About", command=self.show_about)
        help_menu.add_command(label="Legal Disclaimer", command=self.show_disclaimer)
        
    def create_main_layout(self):
        """Create main application layout"""
        # Import panels here
        from gui.network_panel import NetworkPanel
        from gui.attack_panel import AttackPanel
        from gui.packet_panel import PacketPanel
        from gui.visualization_panel import VisualizationPanel
        
        # Main paned window
        self.main_paned = ttk.PanedWindow(self.root, orient=tk.HORIZONTAL)
        self.main_paned.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Left panel
        self.left_panel = ttk.Frame(self.main_paned, width=300)
        self.main_paned.add(self.left_panel, weight=1)
        self.network_panel = NetworkPanel(self.left_panel, self)
        
        # Center panel
        self.center_panel = ttk.Frame(self.main_paned)
        self.main_paned.add(self.center_panel, weight=2)
        self.attack_panel = AttackPanel(self.center_panel, self)
        
        # Right panel
        self.right_panel = ttk.Frame(self.main_paned, width=250)
        self.main_paned.add(self.right_panel, weight=1)
        self.packet_panel = PacketPanel(self.right_panel, self)
        
        # Bottom panel
        self.viz_panel = VisualizationPanel(self.root, self)
        self.viz_panel.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
    def create_status_bar(self):
        """Create status bar at bottom"""
        self.status_bar = ttk.Frame(self.root, relief=tk.SUNKEN, padding=(2, 0))
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Status indicators
        self.status_scan = ttk.Label(self.status_bar, text="üîÑ Scan: Idle", width=20)
        self.status_scan.pack(side=tk.LEFT, padx=5)
        
        self.status_attack = ttk.Label(self.status_bar, text="‚öîÔ∏è Attack: None", width=20)
        self.status_attack.pack(side=tk.LEFT, padx=5)
        
        self.status_packets = ttk.Label(self.status_bar, text="üì¶ Packets: 0", width=15)
        self.status_packets.pack(side=tk.LEFT, padx=5)
        
        self.status_ivs = ttk.Label(self.status_bar, text="üîë IVs: 0", width=15)
        self.status_ivs.pack(side=tk.LEFT, padx=5)
        
        # Time display
        self.status_time = ttk.Label(self.status_bar, text="", width=20)
        self.status_time.pack(side=tk.RIGHT, padx=5)
        
        # Start time updates
        self.update_time()
        
    def update_time(self):
        """Update time in status bar"""
        now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        if hasattr(self, 'status_time'):
            try:
                self.status_time.config(text=now)
            except:
                pass
        self.root.after(1000, self.update_time)
        
    def update_status(self, data):
        """Update status bar with new information"""
        if hasattr(self, 'status_scan') and 'scan' in data:
            try:
                self.status_scan.config(text=f"üîÑ Scan: {data['scan']}")
            except:
                pass
        if hasattr(self, 'status_attack') and 'attack' in data:
            try:
                self.status_attack.config(text=f"‚öîÔ∏è Attack: {data['attack']}")
            except:
                pass
        if hasattr(self, 'status_packets') and 'packets' in data:
            try:
                self.status_packets.config(text=f"üì¶ Packets: {data['packets']}")
            except:
                pass
        if hasattr(self, 'status_ivs') and 'ivs' in data:
            try:
                self.status_ivs.config(text=f"üîë IVs: {data['ivs']}")
            except:
                pass
        
    def process_messages(self):
        """Process message queue"""
        try:
            while True:
                msg = self.message_queue.get_nowait()
                self.handle_message(msg)
        except queue.Empty:
            pass
        finally:
            self.root.after(100, self.process_messages)
            
    def handle_message(self, msg):
        """Handle different message types"""
        msg_type = msg.get('type', '')
        
        if msg_type == 'log':
            self.log(msg.get('message', ''))
        elif msg_type == 'network_found':
            if hasattr(self, 'network_panel'):
                self.network_panel.add_network(msg.get('data', {}))
        elif msg_type == 'client_found':
            if hasattr(self, 'network_panel'):
                self.network_panel.add_client(msg.get('data', {}))
        elif msg_type == 'attack_result':
            if hasattr(self, 'attack_panel'):
                self.attack_panel.add_result(msg.get('data', {}))
        elif msg_type == 'packet_captured':
            if hasattr(self, 'packet_panel'):
                self.packet_panel.add_packet(msg.get('data', {}))
                self.update_packet_count()
        elif msg_type == 'status_update':
            self.update_status(msg.get('data', {}))
            
    def update_packet_count(self):
        """Update packet count in status bar"""
        if hasattr(self, 'packet_panel'):
            try:
                count = self.packet_panel.get_packet_count()
                self.update_status({'packets': count})
            except:
                pass
            
    def log(self, message):
        """Add log message"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        log_msg = f"[{timestamp}] {message}"
        print(log_msg)  # Print to console
        
        # Also try to add to attack panel log if available
        if hasattr(self, 'attack_panel'):
            try:
                self.attack_panel.add_to_log(log_msg)
            except:
                pass
        
    # Menu command handlers
    def new_session(self):
        """Start new session"""
        self.log("New session started")
        
    def load_session(self):
        """Load session"""
        filename = filedialog.askopenfilename(
            title="Load Session",
            filetypes=[("Session files", "*.session"), ("JSON files", "*.json"), ("All files", "*.*")]
        )
        if filename:
            self.log(f"Loading session from {filename}")
            
    def save_session(self):
        """Save session"""
        filename = filedialog.asksaveasfilename(
            title="Save Session",
            defaultextension=".session",
            filetypes=[("Session files", "*.session"), ("JSON files", "*.json")]
        )
        if filename:
            self.log(f"Saving session to {filename}")
            
    def export_results(self):
        """Export results"""
        filename = filedialog.asksaveasfilename(
            title="Export Results",
            defaultextension=".txt",
            filetypes=[("Text files", "*.txt"), ("CSV files", "*.csv"), ("All files", "*.*")]
        )
        if filename:
            self.log(f"Exporting results to {filename}")
            
    def import_capture(self):
        """Import capture"""
        filename = filedialog.askopenfilename(
            title="Import Capture",
            filetypes=[("PCAP files", "*.pcap"), ("All files", "*.*")]
        )
        if filename:
            self.log(f"Importing capture from {filename}")
            
    def show_about(self):
        """Show about dialog"""
        about_text = """Professional WiFi Penetration Testing Framework
Version 1.0.0

A comprehensive educational tool for learning about WiFi security and penetration testing.

Features:
- Network discovery and scanning
- WEP/WPA/WPA2 attack simulations
- Packet capture and analysis
- Real-time visualization
- Educational attack descriptions

Created for classroom use and ethical hacking education.

¬© 2024 - Educational Purpose Only"""
        messagebox.showinfo("About", about_text)
        
    def show_disclaimer(self):
        """Show disclaimer"""
        disclaimer = """LEGAL DISCLAIMER

This tool is for EDUCATIONAL PURPOSES ONLY.

Unauthorized access to computer networks is illegal. This tool should only be used:
- On networks you own
- On networks you have explicit permission to test
- In educational environments under supervision

The authors are not responsible for any misuse of this software.

By using this tool, you agree to use it responsibly and legally."""
        messagebox.showwarning("Disclaimer", disclaimer)
        
    def on_closing(self):
        """Handle window closing"""
        if messagebox.askokcancel("Exit", "Do you want to exit?"):
            # Stop any running attacks
            if hasattr(self, 'wep_attack'):
                try:
                    self.wep_attack.stop()
                except:
                    pass
            if hasattr(self, 'wpa_attack'):
                try:
                    self.wpa_attack.stop()
                except:
                    pass
            if hasattr(self, 'deauth_attack'):
                try:
                    self.deauth_attack.stop()
                except:
                    pass
            if hasattr(self, 'scanner'):
                try:
                    self.scanner.stop_scan()
                except:
                    pass
                
            self.root.destroy()