"""
Network Discovery Panel Module
"""

import tkinter as tk
from tkinter import ttk
import threading


class NetworkPanel:
    """Network discovery and management panel"""
    
    def __init__(self, parent, main_window):
        self.parent = parent
        self.main = main_window
        self.networks = []  # Store networks locally
        
        self.create_widgets()
        
    def create_widgets(self):
        """Create network panel widgets"""
        # Network list frame
        net_frame = ttk.LabelFrame(self.parent, text="Discovered Networks", padding="5")
        net_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Create Treeview with scrollbars
        tree_frame = ttk.Frame(net_frame)
        tree_frame.pack(fill=tk.BOTH, expand=True)
        
        # Define columns
        columns = ('BSSID', 'SSID', 'Ch', 'Enc', 'Signal', 'Clients')
        self.network_tree = ttk.Treeview(tree_frame, columns=columns, show='headings', height=10)
        
        # Define column headings and widths
        column_configs = {
            'BSSID': {'width': 140, 'text': 'BSSID'},
            'SSID': {'width': 120, 'text': 'SSID'},
            'Ch': {'width': 40, 'text': 'Ch'},
            'Enc': {'width': 80, 'text': 'Encryption'},
            'Signal': {'width': 60, 'text': 'Signal'},
            'Clients': {'width': 50, 'text': 'Clients'}
        }
        
        for col in columns:
            self.network_tree.heading(col, text=column_configs[col]['text'])
            self.network_tree.column(col, width=column_configs[col]['width'], anchor='center')
        
        # Scrollbars
        v_scroll = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=self.network_tree.yview)
        h_scroll = ttk.Scrollbar(tree_frame, orient=tk.HORIZONTAL, command=self.network_tree.xview)
        self.network_tree.configure(yscrollcommand=v_scroll.set, xscrollcommand=h_scroll.set)
        
        # Grid layout
        self.network_tree.grid(row=0, column=0, sticky='nsew')
        v_scroll.grid(row=0, column=1, sticky='ns')
        h_scroll.grid(row=1, column=0, sticky='ew')
        
        tree_frame.grid_rowconfigure(0, weight=1)
        tree_frame.grid_columnconfigure(0, weight=1)
        
        # Configure tags for different encryption types
        self.network_tree.tag_configure('WEP', background='#5a3a3a')  # Dark red
        self.network_tree.tag_configure('OPEN', background='#3a5a3a')  # Dark green
        self.network_tree.tag_configure('WPA', background='#3a3a5a')  # Dark blue
        self.network_tree.tag_configure('WPA2', background='#3a3a5a')  # Dark blue
        self.network_tree.tag_configure('WPA3', background='#3a3a5a')  # Dark blue
        self.network_tree.tag_configure('WPA2/WPA3 Mixed', background='#3a3a5a')  # Dark blue
        
        # Bind selection event
        self.network_tree.bind('<<TreeviewSelect>>', self.on_network_select)
        self.network_tree.bind('<Double-Button-1>', self.on_network_double_click)
        
        # Clients list frame
        client_frame = ttk.LabelFrame(self.parent, text="Connected Clients", padding="5")
        client_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Clients treeview
        client_tree_frame = ttk.Frame(client_frame)
        client_tree_frame.pack(fill=tk.BOTH, expand=True)
        
        self.client_tree = ttk.Treeview(client_tree_frame, columns=('MAC', 'Probe', 'Signal'), 
                                       show='headings', height=6)
        self.client_tree.heading('MAC', text='MAC Address')
        self.client_tree.heading('Probe', text='Probe SSID')
        self.client_tree.heading('Signal', text='Signal')
        
        self.client_tree.column('MAC', width=130, anchor='center')
        self.client_tree.column('Probe', width=100, anchor='center')
        self.client_tree.column('Signal', width=60, anchor='center')
        
        client_scroll = ttk.Scrollbar(client_tree_frame, orient=tk.VERTICAL, command=self.client_tree.yview)
        self.client_tree.configure(yscrollcommand=client_scroll.set)
        
        self.client_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        client_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Bind client selection
        self.client_tree.bind('<Double-Button-1>', self.on_client_double_click)
        
        # Scan controls frame
        control_frame = ttk.Frame(self.parent)
        control_frame.pack(fill=tk.X, pady=5)
        
        self.scan_btn = ttk.Button(control_frame, text="‚ñ∂ Start Scan", 
                                   command=self.start_scan, width=15)
        self.scan_btn.pack(side=tk.LEFT, padx=2)
        
        self.stop_btn = ttk.Button(control_frame, text="‚èπ Stop", 
                                   command=self.stop_scan, width=8, state='disabled')
        self.stop_btn.pack(side=tk.LEFT, padx=2)
        
        self.clear_btn = ttk.Button(control_frame, text="üóë Clear", 
                                    command=self.clear_networks, width=8)
        self.clear_btn.pack(side=tk.LEFT, padx=2)
        
        # Filter frame
        filter_frame = ttk.Frame(self.parent)
        filter_frame.pack(fill=tk.X, pady=2)
        
        ttk.Label(filter_frame, text="Filter:").pack(side=tk.LEFT)
        self.filter_var = tk.StringVar(value="All")
        self.filter_combo = ttk.Combobox(filter_frame, textvariable=self.filter_var,
                                        values=['All', 'WEP', 'WPA', 'WPA2', 'WPA3', 'OPEN'],
                                        width=10, state='readonly')
        self.filter_combo.pack(side=tk.LEFT, padx=5)
        self.filter_combo.bind('<<ComboboxSelected>>', self.apply_filter)
        
        # Statistics label
        self.stats_label = ttk.Label(self.parent, text="Networks: 0 | Clients: 0", 
                                     style='Info.TLabel')
        self.stats_label.pack(pady=2)
        
    def start_scan(self):
        """Start network scanning"""
        self.scan_btn.config(state='disabled')
        self.stop_btn.config(state='normal')
        
        # Clear previous networks
        self.clear_networks()
        
        # Start scanner with callback
        self.main.scanner.start_scan(callback=self.scan_callback)
        
        # Update status safely
        try:
            if hasattr(self.main, 'update_status'):
                self.main.update_status({'scan': 'Running'})
        except Exception as e:
            print(f"Status update error: {e}")
        
        self.main.log("Network scan started")
        
    def stop_scan(self):
        """Stop network scanning"""
        self.main.scanner.stop_scan()
        self.scan_btn.config(state='normal')
        self.stop_btn.config(state='disabled')
        self.main.update_status({'scan': 'Idle'})
        self.main.log("Network scan stopped")
        
    def scan_callback(self, result_type, data):
        """Callback for scan results - called from scanner thread"""
        if result_type == 'network':
            # Use after() to safely update GUI from thread
            self.parent.after(0, lambda: self.add_network(data))
        elif result_type == 'client':
            self.parent.after(0, lambda: self.add_client(data))
            
    def add_network(self, network):
        """Add a network to the tree (called from main thread)"""
        # Check if network already exists in tree (avoid duplicates)
        bssid = network.get('bssid', '')
        for item in self.network_tree.get_children():
            if self.network_tree.item(item)['values'][0] == bssid:
                # Update existing item
                self.network_tree.item(item, values=(
                    bssid,
                    network.get('ssid', ''),
                    network.get('channel', ''),
                    network.get('encryption', ''),
                    f"{network.get('signal', -100)} dBm",
                    network.get('clients', 0)
                ))
                return
        
        # Add new network
        encryption = network.get('encryption', '')
        tag = ''
        if encryption == 'WEP':
            tag = 'WEP'
        elif encryption == 'OPEN':
            tag = 'OPEN'
        elif encryption in ['WPA', 'WPA2', 'WPA3', 'WPA2/WPA3 Mixed']:
            tag = encryption
        
        # Insert at beginning to show newest first
        item_id = self.network_tree.insert('', 0, values=(
            bssid,
            network.get('ssid', ''),
            network.get('channel', ''),
            encryption,
            f"{network.get('signal', -100)} dBm",
            network.get('clients', 0)
        ), tags=(tag,))
        
        # Update statistics
        self.update_statistics()
        
        # Log discovery (but not too frequently)
        if len(self.networks) % 5 == 0:
            self.main.log(f"Found {len(self.networks)} networks so far")
        
    def add_client(self, client):
        """Add a client to the tree"""
        self.client_tree.insert('', 'end', values=(
            client.get('mac', ''),
            client.get('probe_ssid', '') or 'Broadcast',
            f"{client.get('signal', -100)} dBm"
        ))
        self.update_statistics()
        
    def on_network_select(self, event):
        """Handle network selection"""
        selection = self.network_tree.selection()
        if selection:
            item = self.network_tree.item(selection[0])
            values = item['values']
            if values and len(values) >= 4:
                bssid = values[0]
                ssid = values[1]
                encryption = values[3]
                
                # Update main window with selected target
                self.main.current_target = {
                    'bssid': bssid,
                    'ssid': ssid,
                    'encryption': encryption
                }
                
                # Update attack panel
                if hasattr(self.main, 'attack_panel'):
                    self.main.attack_panel.set_target(bssid, ssid, encryption)
                
                self.main.log(f"Selected target: {ssid} ({bssid})")
                
    def on_network_double_click(self, event):
        """Handle double-click on network"""
        selection = self.network_tree.selection()
        if selection:
            item = self.network_tree.item(selection[0])
            values = item['values']
            if values:
                self.show_network_details(values)
                
    def on_client_double_click(self, event):
        """Handle double-click on client"""
        selection = self.client_tree.selection()
        if selection:
            item = self.client_tree.item(selection[0])
            values = item['values']
            if values:
                self.show_client_details(values)
                
    def show_network_details(self, network_data):
        """Show detailed network information"""
        dialog = tk.Toplevel(self.parent)
        dialog.title("Network Details")
        dialog.geometry("400x300")
        dialog.transient(self.parent)
        dialog.grab_set()
        
        # Center dialog
        dialog.update_idletasks()
        x = (dialog.winfo_screenwidth() // 2) - (400 // 2)
        y = (dialog.winfo_screenheight() // 2) - (300 // 2)
        dialog.geometry(f'400x300+{x}+{y}')
        
        # Create text widget with details
        text = tk.Text(dialog, wrap=tk.WORD, bg='#2b2b2b', fg='#ffffff')
        text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        details = f"""
NETWORK DETAILS
{'='*40}

BSSID: {network_data[0]}
SSID: {network_data[1]}
Channel: {network_data[2]}
Encryption: {network_data[3]}
Signal: {network_data[4]}
Connected Clients: {network_data[5]}

Security Assessment:
{'‚ö†Ô∏è  WEP - VULNERABLE' if network_data[3] == 'WEP' else 
 '‚ö†Ô∏è  WPA - Outdated' if network_data[3] == 'WPA' else
 '‚úÖ WPA2 - Acceptable' if network_data[3] == 'WPA2' else
 '‚úÖ WPA3 - Secure' if network_data[3] == 'WPA3' else
 '‚ÑπÔ∏è  OPEN - No encryption'}
        """
        
        text.insert(tk.END, details)
        text.config(state='disabled')
        
        # Close button
        ttk.Button(dialog, text="Close", command=dialog.destroy).pack(pady=5)
        
    def show_client_details(self, client_data):
        """Show detailed client information"""
        dialog = tk.Toplevel(self.parent)
        dialog.title("Client Details")
        dialog.geometry("400x200")
        dialog.transient(self.parent)
        dialog.grab_set()
        
        # Center dialog
        dialog.update_idletasks()
        x = (dialog.winfo_screenwidth() // 2) - (400 // 2)
        y = (dialog.winfo_screenheight() // 2) - (200 // 2)
        dialog.geometry(f'400x200+{x}+{y}')
        
        text = tk.Text(dialog, wrap=tk.WORD, bg='#2b2b2b', fg='#ffffff')
        text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        details = f"""
CLIENT DETAILS
{'='*40}

MAC Address: {client_data[0]}
Probe SSID: {client_data[1]}
Signal Strength: {client_data[2]}

This client is currently associated or probing for networks.
        """
        
        text.insert(tk.END, details)
        text.config(state='disabled')
        
        ttk.Button(dialog, text="Close", command=dialog.destroy).pack(pady=5)
        
    def apply_filter(self, event=None):
        """Apply filter to network list"""
        filter_text = self.filter_var.get()
        
        # Clear current items
        for item in self.network_tree.get_children():
            self.network_tree.delete(item)
            
        # Re-add filtered networks
        if filter_text == 'All':
            networks = self.networks
        else:
            networks = [n for n in self.networks 
                       if n.get('encryption') == filter_text]
            
        for network in networks:
            encryption = network.get('encryption', '')
            tag = encryption if encryption in ['WEP', 'OPEN', 'WPA', 'WPA2', 'WPA3', 'WPA2/WPA3 Mixed'] else ''
            
            self.network_tree.insert('', 'end', values=(
                network.get('bssid', ''),
                network.get('ssid', ''),
                network.get('channel', ''),
                encryption,
                f"{network.get('signal', -100)} dBm",
                network.get('clients', 0)
            ), tags=(tag,))
            
        self.update_statistics()
            
    def clear_networks(self):
        """Clear all networks and clients"""
        for item in self.network_tree.get_children():
            self.network_tree.delete(item)
        for item in self.client_tree.get_children():
            self.client_tree.delete(item)
        self.networks.clear()
        if hasattr(self.main, 'scanner'):
            self.main.scanner.clear_results()
        self.update_statistics()
        self.main.log("Network list cleared")
        
    def clear_all(self):
        """Clear all panel data"""
        self.clear_networks()
        
    def update_statistics(self):
        """Update statistics label"""
        networks = len(self.network_tree.get_children())
        clients = len(self.client_tree.get_children())
        self.stats_label.config(text=f"Networks: {networks} | Clients: {clients}")
        
        # Update main window status
        if hasattr(self.main, 'update_status'):
            self.main.update_status({'packets': networks})

  